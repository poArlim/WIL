## 덱의 특징
덱(deque)의 자료구조는 Double Ended Queue 라는 구조로, 이는 일반적인 큐(Queue) 와 비슷하지만 삽입과 삭제가 양쪽 모두에서 가능하다는 특징이 있습니다.  
일반적인 큐 자료구조는 First In First Out(FIFO), 즉 먼저 들어온 데이터가 먼저 삭제되는 구조이지만 덱(deque)는 이 과정이 양쪽에서 모두 가능하여 큐와 스택의 장점만을 모아 놓은 자료구조라고 볼 수 있습니다.  
덱 역시 벡터(Vector)와 동일하게 그 크기가 고정되어 있지 않고 동적으로 변하며 컨테이너의 끝에서 데이터를 삽입, 삭제를 할 때 성능이 좋으며 중간에서의 삽입, 삭제는 성능이 떨어진다는 특징이 있습니다.  
이러한 특징들은 아래와 같이 정리할 수 있습니다.  
1. 컨테이너의 크기가 가변적이므로 메모리 공간의 낭비를 막을 수 있다.
2. 벡터에서는 컨테이너의 맨 뒤에서만 데이터를 삽입, 삭제가 가능했지만 덱은 컨테이너의 양 끝에서 데이터의 삽입, 삭제 시 성능이 좋습니다.
3. 덱은 큐와 스택이 결합된 자료구조로 컨테이너의 중간에 데이터를 삽입, 삭제할 때에는 벡터보다도 떨어지는 성능을 보여줍니다.
4. 데이터에 랜덤접근이 가능합니다.


## 덱의 사용방법
우선적으로 덱 헤더 파일을 포함해야 합니다.  
`#include <deque>`

선언은 deque<자료type> 변수이름 으로 할 수 있으며 new 를 사용한 동적 할당도 가능합니다.
```c++
deque<int> newVec;
deque<int> *newVec2 = new vector<int>;
```

덱에서 자주 사용되는 멤버함수는 벡터의 멤버함수와 동일하며 push_front(), pop_front() 가 추가로 있습니다.
|멤버|설명|
|:---|:---|
|push_back|마지막에 데이터를 하나 추가|
|pop_back|마지막 데이터 하나 삭제|
|push_front|처음에 데이터를 하나 추가|
|pop_front|처음 데이터 하나 삭제|
|front|첫번째 원소의 참조값 반환|
|back|마지막 원소의 참조값 반환|
|begin|첫번째 위치의 반복자 반환|
|end|마지막 다음 위치의 반복자 반환|
|rbegin|역방향으로 첫번재 위치의 반복자 반환|
|rend|역방향으로 마지막 다음 위치의 반복자 반환|
|at|특정 위치 원소의 참조값 반환(배열식으로 접근도 가능)|
|clear|모든 데이터 삭제|
|empty|덱이 비어 있으면 true, 아니면 false 반환|
|insert|특정 위치에 원소 삽입|
|size|데이터의 개수를 반환|
|swap|두 개의 덱을 서로 맞바꿈|
|erase|특정한 위치의 원소 혹은 지정한 위치의 원소들을 삭제|
|assign|특정 데이터로 덱을 채움, 덱에 데이터가 이미 있다면 모두 삭제되고 새로 채워짐|

각각의 멤버의 사용 방법은 벡터_vector.md 포스트를 참고하면 됩니다.
